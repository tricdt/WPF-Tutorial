<#@ template debug="True"#>
<#@ assembly name="System.Xml" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="Microsoft.VisualStudio.OLE.Interop" #>
<#@ assembly name="Microsoft.VisualStudio.Shell" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="Microsoft.VisualStudio.Shell" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#+
public class LocalizerTemplate : TextTransformation {
    string localizerEnum;
    string localizerClassName;
    string[,] inputData;
    ITextTemplatingEngineHost Host { get; set; }
    IEnumerable<LocalizationItem> Items { get { return GetLocalizationItems();} }
    
    public LocalizerTemplate(ITextTemplatingEngineHost host, string localizerEnum, string localizerClassName, string[,] inputData) {
        this.localizerEnum = localizerEnum;
        this.localizerClassName = localizerClassName;
        this.inputData = inputData;
        this.Host = host;
    }
    public override string TransformText() {
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

    #region enum <#= localizerEnum #>
    public enum <#= localizerEnum #> {
<#+
    foreach(LocalizationItem item in Items) {
        if(!string.IsNullOrEmpty(item.EnumValueAttributes)) {
#>
        <#= item.EnumValueAttributes #>
<#+
        }
#>
        <#= item.EnumValueName #>,
<#+        
    }
#>
    }
    #endregion

    #region <#= localizerClassName #> 
    public partial class <#= localizerClassName #> {
<#+         
    foreach(LocalizationItem item in Items) {
         if(!item.EnumValueAttributes.Contains("Obsolete")) {
#>
        public static string <#= item.EnumValueName #> { get { return Active.GetLocalizedString(<#= localizerEnum #>.<#= item.EnumValueName #>); } }
<#+
        }
    }
#>

        void AddStrings() {
<#+         
    foreach(LocalizationItem item in Items) {
         if(!item.EnumValueAttributes.Contains("Obsolete")) {
#>
            AddString(<#= localizerEnum #>.<#= item.EnumValueName #>, <#= item.DefaultValue #>);
<#+
        }
    }
#>
        }
    }
     #endregion

<#+    
        return GenerationEnvironment.ToString();
    }
    string GenerateResx() {
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
#><?xml version="1.0" encoding="utf-8"?>
<root>
<#+
        WriteWarning();
        WriteResxHeader();
        foreach(LocalizationItem item in Items) {
             if(!item.EnumValueAttributes.Contains("Obsolete")) {
#>
  <data name="<#= localizerEnum #>.<#= item.EnumValueName #>" xml:space="preserve">
    <value><#= ConvertToXmlValue(item.DefaultValue) #></value>
  </data>    
<#+            
            }
        }        
#></root>
<#+
        return GenerationEnvironment.ToString();    
    }
    
    class LocalizationItem {
        public string EnumValueName { get; set; }
        public string DefaultValue { get; set; }
        public string EnumValueAttributes { get; set; }
    }
    IEnumerable<LocalizationItem> GetLocalizationItems() {
        LocalizationItem item = new LocalizationItem();
        int size = inputData.GetUpperBound(0);
        for(int line = 0; line <= size; line++) {
            item.EnumValueName = inputData[line, 0];
            item.DefaultValue = "\"" + inputData[line, 1] + "\"";
            item.EnumValueAttributes = inputData[line, 2];
            yield return item;
        }
    }
    public void Render(TextTransformation baseTemplate) {
        baseTemplate.Write(BuildText());
        new AdditionalItemBuilder(Host).Write("LocalizationRes.resx", GenerateResx());
    }
    string BuildText() {
        Errors.Clear();
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);

        Initialize();
        if(!Errors.HasErrors) 
            return this.TransformText(); 
        
        return this.GenerationEnvironment.ToString();
    }
    string ConvertToXmlValue(string s) {
        s = s.Replace("&", "&amp;");
        s = s.Replace("<", "&lt;");
        s = s.Replace(">", "&gt;");
        s = s.Replace("\\\"", "&quot;");
        s = s.Replace("\\t", "\t");
        s = s.Replace("\\r\\n", "\r\n");
        s = s.Replace("\\n", "\r\n");
        s = s.Replace("\\r", "\r\n");
        s = s.Trim('"');
        return s;
    }
    void WriteWarning() {
#>
<!--***************************************************************************
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//*****************************************************************************
-->
<#+
    }
    void WriteResxHeader() {
#>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
<#+            
    }
}
class AdditionalItemBuilder {
    ITextTemplatingEngineHost Host { get; set; }
    public AdditionalItemBuilder(ITextTemplatingEngineHost host) {
        Host = host;
    }
    public void Write(string outputFileName, string content) {
        string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
        string outputFilePath = Path.Combine(templateDirectory, outputFileName);  

        ProjectItem templateProjectItem = GetTemplateProjectItem();
        ProjectItem subItem  = GetSubitem(templateProjectItem, outputFilePath);
        
        if(subItem == null) {
            File.WriteAllText(outputFilePath, content);
            templateProjectItem.ProjectItems.AddFromFile(outputFilePath); 
        } else {
            SourceControl sourceControl = templateProjectItem.DTE.SourceControl;
            bool allowChange = true;
            if(sourceControl != null && sourceControl.IsItemUnderSCC(outputFilePath) && !sourceControl.IsItemCheckedOut(outputFilePath)) {
                allowChange = sourceControl.CheckOutItem(outputFilePath);
            }    
            if(!allowChange) 
                return;
            
            bool wasClosed = false;
            if(subItem.Document == null) {
                wasClosed = true;
                subItem.Open(EnvDTE.Constants.vsViewKindTextView);
            }                
            TextSelection text = (TextSelection)subItem.Document.Selection;
            text.SelectAll();
            text.Delete(0);
            text.Insert(content, (int)vsInsertFlags.vsInsertFlagsContainNewText);
            if(wasClosed)
                subItem.Document.Close(vsSaveChanges.vsSaveChangesYes);
            else {
                text.StartOfDocument(false);
            }                
        }
    }
    ProjectItem GetSubitem(ProjectItem projectItem, string path) {
        foreach(ProjectItem subItem in projectItem.ProjectItems)
            if(subItem.Name == Path.GetFileName(path))
                return subItem;    
        return null;
    }
    EnvDTE.ProjectItem GetTemplateProjectItem() {
        EnvDTE.Project dteProject = GetTemplateProject();

        IVsProject vsProject = DteProjectToVsProject(dteProject);

        int iFound = 0;
        uint itemId = 0;
        VSDOCUMENTPRIORITY[] pdwPriority = new VSDOCUMENTPRIORITY[1];
        int result = vsProject.IsDocumentInProject(Host.TemplateFile, out iFound, pdwPriority, out itemId);
        if (result != VSConstants.S_OK)
            throw new Exception("Unexpected error calling IVsProject.IsDocumentInProject");
        if (iFound == 0)
            throw new Exception("Cannot retrieve ProjectItem for template file");
        if (itemId == 0)
            throw new Exception("Cannot retrieve ProjectItem for template file");

        Microsoft.VisualStudio.OLE.Interop.IServiceProvider itemContext = null;
        result = vsProject.GetItemContext(itemId, out itemContext);
        if (result != VSConstants.S_OK)
            throw new Exception("Unexpected error calling IVsProject.GetItemContext");
        if (itemContext == null)
            throw new Exception("IVsProject.GetItemContext returned null");
    
        ServiceProvider itemContextService = new ServiceProvider(itemContext);
        EnvDTE.ProjectItem templateItem = (EnvDTE.ProjectItem)itemContextService.GetService(typeof(EnvDTE.ProjectItem));
        Debug.Assert(templateItem != null, "itemContextService.GetService returned null");

        return templateItem;
    }

    EnvDTE.Project GetTemplateProject() {
        IServiceProvider hostServiceProvider = (IServiceProvider)Host;
        if (hostServiceProvider == null)
            throw new Exception("Host property returned unexpected value (null)");

        EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
        if (dte == null)
            throw new Exception("Unable to retrieve EnvDTE.DTE");

        Array activeSolutionProjects = (Array)dte.ActiveSolutionProjects;
        if (activeSolutionProjects == null)
            throw new Exception("DTE.ActiveSolutionProjects returned null");

        EnvDTE.Project dteProject = (EnvDTE.Project)activeSolutionProjects.GetValue(0);
        if (dteProject == null)
            throw new Exception("DTE.ActiveSolutionProjects[0] returned null");

        return dteProject;
    }

    static IVsProject DteProjectToVsProject(EnvDTE.Project project) {
        if (project == null) 
            throw new ArgumentNullException("project");
            
        string projectGuid = null;        

        using (XmlReader projectReader = XmlReader.Create(project.FileName))
        {
            projectReader.MoveToContent();
            object nodeName = projectReader.NameTable.Add("ProjectGuid");
            while (projectReader.Read())
            {
                if (Object.Equals(projectReader.LocalName, nodeName))
                {
                    projectGuid = (string)projectReader.ReadElementContentAsString(); 
                    break;
                }
            }
        }
        if (string.IsNullOrEmpty(projectGuid))
            throw new Exception("Unable to find ProjectGuid element in the project file");

        Microsoft.VisualStudio.OLE.Interop.IServiceProvider dteServiceProvider = 
            (Microsoft.VisualStudio.OLE.Interop.IServiceProvider)project.DTE;
        IServiceProvider serviceProvider = new ServiceProvider(dteServiceProvider); 
        IVsHierarchy vsHierarchy = VsShellUtilities.GetHierarchy(serviceProvider, new Guid(projectGuid));
            
        IVsProject vsProject = (IVsProject)vsHierarchy;
        if (vsProject == null)
            throw new ArgumentException("Project is not a VS project.");
        return vsProject;
    }
}
#>